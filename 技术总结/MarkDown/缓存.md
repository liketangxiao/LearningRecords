# 缓存

## 缓存设计

### CPU占用

- 正则表达式计算占用CPU
考虑将计算结果缓存起来

### 数据库IO占用

- 连接池比较繁忙，将查询结果缓存
解决数据库IO占用，提高查询性能

## 进程内缓存

### 适合数据量较小，更新不频繁的数据
如果更新频繁，可以设置较短超时时间

### concurrentHashMap

- 缓存较小，固定不变的，如反射的Method,feild,链接

### LRUMap

- 有淘汰数据的算法

### Guava Chache

- 第三方缓存

### Caffeine

- 第三方缓存，支持淘汰算法，读写性能比Guava Chache好

## 分布式缓存

### 适合大量数据，更新频率高的数据

### MemCache

- 只支持key-value，不支持持久化，但吞吐量好

### Redis

- 数据结构丰富，支持持久化

### Tair

- 数据结构丰富，支持持久化

## 多级缓存

### 问题，有redis做缓存了，为什么还需要进程内缓存

### 1、redis在全量同步时不可用，会造成雪崩

### 2、redis会有IO序列化和反序列化，没本地方法快

### 缓存更新，使用redis的pud/sub通知应用更新缓存，
redis挂了也可以使用超时设定去刷新缓存

## 缓存更新

### 先删缓存，再更新数据库

- 问题：删了缓存有读数据依然是旧数据，然后再缓存旧数据

### 先更新数据库，再删缓存

- 问题：

## 缓存三贱客

### 缓存穿透

- 数据库没有，缓存自然没有，这样请求多数据库压力就大
- 设计将null结果也缓存起来，增加维护成本，
在插入的时候删除缓存，或设置超时时间
- 设置过滤器将一些不可能存在的数据直接过滤，
小数据用bitMap,大数据用布隆过滤器

### 缓存击穿

- 缓存设置超时时间，热点数据key删除后大量请求访问数据库
- 设计分布式锁，加载数据锁住这个数据key，
其他线程可以采用重试策略
- 设计超时时间自动刷新，而不是到期自动淘汰

### 缓存雪崩

- 缓存不可用或者大量缓存同时失效，请求直接访问数据库
数据库压力过大导致系统雪崩
- 设计监控系统缓存的健康程度，适当扩容缓存
- 采用多级缓存，不同级别设置超时时间不同
- 设置随机缓存过期时间，尽量让key不是同时过期

## 设计会忽略的点

### 序列化

### GC调优

### 缓存监控

## https://juejin.im/post/5b849878e51d4538c77a974a

