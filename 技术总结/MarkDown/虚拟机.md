# 虚拟机

## 数据区域

![jvm-memory-structure](assets/jvm-memory-structure.jpg)

### 程序计数器

- 记录执行程序字节码的地址

### 虚拟机栈

- 方法执行创建,存储局部变量,操作数栈,常量池引用

### 本地方法栈

- 为本地方法服务

### 堆

为对象分配内存,GC工作的主要区域

- 新生代

  新对象再Eden区, 回收存活到从From Survivor 到To Survivor

- 老年代

  java8元数据取待老年代, 保存在本机内存中

- 永久代

### 方法区

- 被加载的类信息, 常量, 静态变量

### 运行是常量池

## 垃圾收集

### 判断对象存活

- 引用计数算法

	- 被引用计数加1,引用失效计数减1

- 可达性分析算法

	- GC Roots作为起始点,可达的是存活的,不可达的可被回收
	- GC Roots包含虚拟机栈/本地方法栈/方法区静态属性/方法区常量的对象引用
	- 强引用

		- 通过new的对象, 不会被回收

	- 软引用

		- SoftReference类创建的引用, 内存不够会被回收

	- 弱引用

		- WeakReference类创建的引用, 一定会被回收

	- 虚引用

		- PhantomReference类创建的引用

### 垃圾收集算法

- 标记-清除

	- 存活的标记, 清楚未被标记的对象

- 标记-整理

	- 存活的移动到一端, 清理末尾的对象

- 复制

	- 内存分为两部分, 使用的一部分存活的复制到未使用的一部分

- 分代收集

	- 新生代-复制算法
	- 老年代-标记清除或标记整理

### 垃圾收集器

- serial

	- 串行执行, 单线程效率高

- parNew

	- serial多线程版, 能与CMS配合使用

- parallel scavenge
- serial Old
- parallel Old
- CMS(Concurrent Mark Sweep)

	- 并发收集,低停顿
	- 使用标记-清楚算法

- G1

	- 可以对新生代/老年代一起回收

### 对象分配

- 新生对象优先新生代, Eden区不足发起MinorGC
- 大对象-老年代
- 长期存活对象老年代
- 对象动态年龄判定
- 空间分配担保

	- 老年代空间足,MinorGC就是安全的,不足担保失败就会发起FullGC

### 回收策略

- Mirror Gc, Eden区不足时发起
- Full Gc

	- System.gc();
	- 老年代满了,大对象和数组
	- mirror Gc担保失败
	- Concurrent Mode Fail

## 类加载

### 类加载过程

- 加载

	- 获取类的二进制字节流, jar/war包, 运行时动态代理, JSP文件获取
	- 将静态存储结构转化为方法区的运行时存储结构
	- 在内存中生成Class对象,作为方法区中类的访问入口

- 验证

	- 文件格式, 元数据, 字节码, 符号引用

- 准备

	- Static分配内存并初始化
	- 实例变量不分配内存,初始化为0

- 解析

	- 将常量池的符号引用替换为直接引用

- 初始化

	- 虚拟机执行构造方法的过程

- 使用
- 卸载

### 类加载器

- 启动类加载器

	- 加载被虚拟机识别的存放再lib或Xbootclasspath指定的
	- BootstrapClassLoader

- 扩张类加载器

	- Extension ClassLoader
	- 加载lib/ext下的类库

- 应用程序类加载器

	- AppClassLoader
	- 加载用户路径classpath的类库

- 双亲委派模型

	- 加载类时先委派父类加载器,父类无法加载时才尝试加载
	- 加载类都会经过顶层启动类加载器，保证是同一个类
	- 例如定义了一个Object方法, 会首先使用启动类加载器
所以所有的Object类都是rt.jar下的Object

